<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Faction Attack Logs</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    tr:nth-child(even) { background-color: #fafafa; }
    select, input[type="datetime-local"] { margin: 5px 10px 10px 0; padding: 5px; }
    .bleed { background-color: #ffcccc; }
    .member-bleed { margin-top: 10px; font-weight: bold; }
    .collapsible { cursor: pointer; padding: 10px; border: 1px solid #ccc; margin-top: 10px; background: #eee; }
    .content { display: none; padding: 10px; border: 1px solid #ccc; border-top: none; }
  </style>
</head>
<body>
  <h1>Faction Attack Logs</h1>

  <!-- Filters -->
  <label for="factionFilter">Filter by Enemy Faction:</label>
  <select id="factionFilter">
    <option value="all">All</option>
    <option value="IRON FORGE HQ">IRON FORGE HQ</option>
    <option value="Mana">Mana</option>
  </select>

  <label for="startDate">Start Date/Time (UTC):</label>
  <input type="datetime-local" id="startDate">

  <label for="endDate">End Date/Time (UTC):</label>
  <input type="datetime-local" id="endDate">

  <p>
    Total Bleed (respect lost to selected faction): <span id="totalBleed">0</span><br>
    Total Bleed Attacks: <span id="totalBleedAttacks">0</span>
  </p>

  <!-- Member bleed summaries -->
  <div id="memberBleedSummary"></div>

  <div id="membersContainer"></div>

  <script>
    const factionFilter = document.getElementById('factionFilter');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const totalBleedSpan = document.getElementById('totalBleed');
    const totalBleedAttacksSpan = document.getElementById('totalBleedAttacks');
    const memberBleedSummary = document.getElementById('memberBleedSummary');
    const membersContainer = document.getElementById('membersContainer');
    let members = [];
    let allData = {};

    function formatDate(unixTime) {
      if (!unixTime) return '';
      const d = new Date(unixTime * 1000);
      const year = d.getUTCFullYear();
      const month = String(d.getUTCMonth() + 1).padStart(2, '0');
      const day = String(d.getUTCDate()).padStart(2, '0');
      const hours = String(d.getUTCHours()).padStart(2, '0');
      const minutes = String(d.getUTCMinutes()).padStart(2, '0');
      const seconds = String(d.getUTCSeconds()).padStart(2, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
    }

    function utcInputToUnix(inputValue) {
      if (!inputValue) return null;
      const [datePart, timePart] = inputValue.split('T');
      const [year, month, day] = datePart.split('-').map(Number);
      const [hour, minute] = timePart.split(':').map(Number);
      const d = new Date(Date.UTC(year, month - 1, day, hour, minute, 0));
      return Math.floor(d.getTime() / 1000);
    }

    async function loadMembers() {
      // Hardcoding member JSON filenames. In a live system, a backend could provide the list dynamically.
      const attackFiles = ['Deviyl_attacks.json','Caits_attacks.json'];
      members = attackFiles.map(f => f.replace('_attacks.json',''));
      await loadAttacks();
    }

    async function loadAttacks() {
      for (const member of members) {
        try {
          const response = await fetch(`./attacks/${member}_attacks.json`);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          allData[member] = data.map(attack => {
            return {
              attackerName: attack.attacker?.name ?? 'someone',
              defenderName: attack.defender?.name ?? 'someone',
              respectGained: attack.respect_gain ?? 0,
              respectLost: attack.respect_loss ?? 0,
              attackerFaction: attack.attacker?.faction?.name ?? 'none',
              defenderFaction: attack.defender?.faction?.name ?? 'none',
              enemyFaction: attack.attacker?.name === member ? (attack.defender?.faction?.name ?? 'none') : (attack.attacker?.faction?.name ?? 'none'),
              result: attack.result ?? '',
              startedUnix: attack.started ?? 0,
              endedUnix: attack.ended ?? 0,
            };
          });
        } catch (err) {
          console.error(`Failed to load attacks for ${member}:`, err);
          allData[member] = [];
        }
      }
      renderMembers();
      updateBleed();
    }

    function renderMembers() {
      membersContainer.innerHTML = '';
      members.forEach(member => {
        const collapsible = document.createElement('div');
        collapsible.className = 'collapsible';
        collapsible.textContent = member;
        const content = document.createElement('div');
        content.className = 'content';

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th>Attacker</th>
            <th>Defender</th>
            <th>Result</th>
            <th>Respect Gained</th>
            <th>Respect Lost</th>
            <th>Enemy Faction</th>
            <th>Started (UTC)</th>
            <th>Ended (UTC)</th>
          </tr>
        `;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        table.appendChild(tbody);
        content.appendChild(table);

        collapsible.addEventListener('click', () => {
          content.style.display = content.style.display === 'block' ? 'none' : 'block';
        });

        membersContainer.appendChild(collapsible);
        membersContainer.appendChild(content);

        allData[member].forEach(a => {
          const row = document.createElement('tr');
          row.dataset.defender = a.defenderName;
          row.dataset.attackerFaction = a.attackerFaction;
          row.dataset.enemyFaction = a.enemyFaction;
          row.dataset.respectLost = a.respectLost;
          row.dataset.respectGained = a.respectGained;
          row.dataset.startedUnix = a.startedUnix;
          row.dataset.endedUnix = a.endedUnix;
          row.innerHTML = `
            <td>${a.attackerName}</td>
            <td>${a.defenderName}</td>
            <td>${a.result}</td>
            <td>${a.respectGained}</td>
            <td>${a.respectLost}</td>
            <td>${a.enemyFaction}</td>
            <td>${formatDate(a.startedUnix)}</td>
            <td>${formatDate(a.endedUnix)}</td>
          `;
          tbody.appendChild(row);
        });
      });
    }

    function updateBleed() {
      const selectedFaction = factionFilter.value;
      const startUnix = utcInputToUnix(startDateInput.value);
      const endUnix = utcInputToUnix(endDateInput.value);

      let totalBleed = 0;
      let totalBleedAttacks = 0;
      const perMemberBleed = {};
      const perMemberBleedAttacks = {};
      const perMemberOutgoing = {};
      members.forEach(m => {
        perMemberBleed[m] = 0;
        perMemberBleedAttacks[m] = 0;
        perMemberOutgoing[m] = 0;
      });

      members.forEach(member => {
        const tbody = membersContainer.querySelectorAll('.content table tbody')[members.indexOf(member)];
        tbody.querySelectorAll('tr').forEach(row => {
          let showRow = (selectedFaction === 'all' || row.dataset.enemyFaction === selectedFaction);

          const attackStart = Number(row.dataset.startedUnix);
          const attackEnd = Number(row.dataset.endedUnix);
          if (startUnix !== null && attackEnd < startUnix) showRow = false;
          if (endUnix !== null && attackStart > endUnix) showRow = false;

          row.style.display = showRow ? '' : 'none';

          const isDefender = row.dataset.defender === member;
          const respectLost = Number(row.dataset.respectLost);
          const respectGained = Number(row.dataset.respectGained);
          const isAttackerFromSelectedFaction = row.dataset.attackerFaction === selectedFaction;

          if (showRow && isDefender && isAttackerFromSelectedFaction && respectLost > 0) {
            row.classList.add('bleed');
            totalBleed += respectLost;
            totalBleedAttacks++;
            perMemberBleed[member] += respectLost;
            perMemberBleedAttacks[member] += 1;
          } else {
            row.classList.remove('bleed');
          }

          // outgoing attacks
          if (showRow && row.dataset.attackerFaction === member && row.dataset.enemyFaction === selectedFaction) {
            perMemberOutgoing[member] += respectGained;
          }
        });
      });

      totalBleedSpan.textContent = totalBleed;
      totalBleedAttacksSpan.textContent = totalBleedAttacks;

      memberBleedSummary.innerHTML = '';
      members.forEach(member => {
        const div = document.createElement('div');
        div.className = 'member-bleed';
        div.textContent = `${member}: ${perMemberBleed[member]} bleed from ${perMemberBleedAttacks[member]} attacks, ${perMemberOutgoing[member]} respect gained outgoing`;
        memberBleedSummary.appendChild(div);
      });
    }

    factionFilter.addEventListener('change', updateBleed);
    startDateInput.addEventListener('change', updateBleed);
    endDateInput.addEventListener('change', updateBleed);

    loadMembers();
  </script>
</body>
</html>
